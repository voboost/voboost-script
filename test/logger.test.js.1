import test from 'ava';
import { Logger } from '../lib/logger.js';

// Store original console.log
const originalConsoleLog = console.log;
let consoleLogCalls = [];

// Helper to reset mocks
function resetMocks() {
    consoleLogCalls = [];
    console.log = (...args) => {
        consoleLogCalls.push(args.join(' '));
    };
}

// Helper to restore console
function restoreConsole() {
    console.log = originalConsoleLog;
}

// === Logger Class Tests ===

test('Logger constructor sets source', (t) => {
    const logger = new Logger('test-module');
    t.is(logger.source, 'test-module');
});

test('Logger.error logs with correct format', (t) => {
    resetMocks();

    const logger = new Logger('test-module');
    logger.error('Error occurred');

    t.is(consoleLogCalls.length, 1);
    t.true(consoleLogCalls[0].includes('[-]'));
    t.true(consoleLogCalls[0].includes('test-module'));
    t.true(consoleLogCalls[0].includes('Error occurred'));

    restoreConsole();
});

test('Logger.info logs with correct format', (t) => {
    resetMocks();

    const logger = new Logger('test-module');
    logger.info('Processing started');

    t.is(consoleLogCalls.length, 1);
    t.true(consoleLogCalls[0].includes('[+]'));
    t.true(consoleLogCalls[0].includes('test-module'));
    t.true(consoleLogCalls[0].includes('Processing started'));

    restoreConsole();
});

test('Logger.debug logs with correct format', (t) => {
    resetMocks();

    const logger = new Logger('test-module');
    logger.debug('Debug info');

    t.is(consoleLogCalls.length, 1);
    t.true(consoleLogCalls[0].includes('[*]'));
    t.true(consoleLogCalls[0].includes('test-module'));
    t.true(consoleLogCalls[0].includes('Debug info'));

    restoreConsole();
});

test('Logger formats all log levels correctly', (t) => {
    resetMocks();

    const logger = new Logger('test-module');
    logger.error('Error message');
    logger.info('Info message');
    logger.debug('Debug message');

    t.is(consoleLogCalls.length, 3);
    t.true(consoleLogCalls[0].includes('[-] test-module: Error message'));
    t.true(consoleLogCalls[1].includes('[+] test-module: Info message'));
    t.true(consoleLogCalls[2].includes('[*] test-module: Debug message'));

    restoreConsole();
});

// === Timestamp Tests ===

test('Logger includes timestamp in correct format', (t) => {
    resetMocks();

    const logger = new Logger('test-module');
    logger.info('test message');

    t.is(consoleLogCalls.length, 1);
    const timestampPart = consoleLogCalls[0].split(' ')[0] + ' ' + consoleLogCalls[0].split(' ')[1];
    const regex = /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{3}$/;
    t.true(regex.test(timestampPart));

    restoreConsole();
});

test('Logger timestamp has correct length', (t) => {
    resetMocks();

    const logger = new Logger('test-module');
    logger.info('test message');

    t.is(consoleLogCalls.length, 1);
    const timestampPart = consoleLogCalls[0].split(' ')[0] + ' ' + consoleLogCalls[0].split(' ')[1];
    t.is(timestampPart.length, 23); // YYYY-MM-DD HH:mm:ss.SSS

    restoreConsole();
});

// === Edge Cases ===

test('Logger handles empty source gracefully', (t) => {
    resetMocks();

    const logger = new Logger('');
    logger.info('test message');

    t.is(consoleLogCalls.length, 1);
    t.true(consoleLogCalls[0].includes(': test message'));

    restoreConsole();
});

test('Logger handles empty message gracefully', (t) => {
    resetMocks();

    const logger = new Logger('test-source');
    logger.info('');

    t.is(consoleLogCalls.length, 1);
    t.true(consoleLogCalls[0].includes('test-source:'));

    restoreConsole();
});

test('Logger handles special characters in message', (t) => {
    resetMocks();

    const message = 'Test with "quotes" and <brackets> and \n newlines';
    const logger = new Logger('test-source');
    logger.info(message);

    t.is(consoleLogCalls.length, 1);
    t.true(consoleLogCalls[0].includes('quotes'));
    t.true(consoleLogCalls[0].includes('brackets'));

    restoreConsole();
});

test('Logger handles unicode characters in message', (t) => {
    resetMocks();

    const message = 'Unicode: æ—¥æœ¬èªž ä¸­æ–‡ í•œêµ­ì–´ ðŸŽ‰';
    const logger = new Logger('test-source');
    logger.info(message);

    t.is(consoleLogCalls.length, 1);
    t.true(consoleLogCalls[0].includes('æ—¥æœ¬èªž'));
    t.true(consoleLogCalls[0].includes('ðŸŽ‰'));

    restoreConsole();
});

test('Logger handles very long messages', (t) => {
    resetMocks();

    const message = 'A'.repeat(10000);
    const logger = new Logger('test-source');
    logger.info(message);

    t.is(consoleLogCalls.length, 1);
    t.true(consoleLogCalls[0].length > 10000);

    restoreConsole();
});

test('Logger handles special characters in source', (t) => {
    resetMocks();

    const logger = new Logger('test-module-v2.0');
    logger.info('test message');

    t.is(consoleLogCalls.length, 1);
    t.true(consoleLogCalls[0].includes('test-module-v2.0'));

    restoreConsole();
});

// === Multiple Logger Instances ===

test('Multiple logger instances work independently', (t) => {
    resetMocks();

    const logger1 = new Logger('module-1');
    const logger2 = new Logger('module-2');

    logger1.info('Message from module 1');
    logger2.info('Message from module 2');

    t.is(consoleLogCalls.length, 2);
    t.true(consoleLogCalls[0].includes('module-1'));
    t.true(consoleLogCalls[1].includes('module-2'));

    restoreConsole();
});

test('Logger instances maintain separate sources', (t) => {
    const logger1 = new Logger('module-1');
    const logger2 = new Logger('module-2');

    t.is(logger1.source, 'module-1');
    t.is(logger2.source, 'module-2');
});

// === Integration Tests ===

test('Complete logging flow with all levels', (t) => {
    resetMocks();

    const logger = new Logger('integration-test');

    logger.error('Error occurred');
    logger.info('Processing started');
    logger.debug('Debug info');

    t.is(consoleLogCalls.length, 3);
    t.true(consoleLogCalls[0].includes('[-]'));
    t.true(consoleLogCalls[1].includes('[+]'));
    t.true(consoleLogCalls[2].includes('[*]'));
    t.true(consoleLogCalls[0].includes('integration-test'));
    t.true(consoleLogCalls[1].includes('integration-test'));
    t.true(consoleLogCalls[2].includes('integration-test'));

    restoreConsole();
});

test('Logger works with typical agent usage pattern', (t) => {
    resetMocks();

    const logger = new Logger('weather-widget-mod');

    logger.info('Agent started');
    logger.debug('Loading config');
    logger.info('Config loaded');
    logger.debug('Installing hooks');
    logger.info('Hooks installed');

    t.is(consoleLogCalls.length, 5);
    t.true(consoleLogCalls.every(log => log.includes('weather-widget-mod')));

    restoreConsole();
});

// === Logger.raw() Tests ===

test('Logger.raw() instance method outputs without timestamp', (t) => {
    resetMocks();

    const logger = new Logger('test-module');
    const preformattedLine = '2024-12-15 14:30:45.123 [+] frida-script: message from Frida';

    logger.raw(preformattedLine);

    t.is(consoleLogCalls.length, 1);
    t.is(consoleLogCalls[0], preformattedLine);

    // Verify no double timestamp
    const timestampMatches = consoleLogCalls[0].match(/\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{3}/g);
    t.is(timestampMatches.length, 1, 'Should have exactly one timestamp');

    restoreConsole();
});

test('Logger.raw() static method outputs without timestamp', (t) => {
    resetMocks();

    const preformattedLine = '2024-12-15 14:30:45.456 [*] frida-output: debug message';

    Logger.raw(preformattedLine);

    t.is(consoleLogCalls.length, 1);
    t.is(consoleLogCalls[0], preformattedLine);

    // Verify no double timestamp
    const timestampMatches = consoleLogCalls[0].match(/\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{3}/g);
    t.is(timestampMatches.length, 1, 'Should have exactly one timestamp');

    restoreConsole();
});

test('Logger.raw() preserves original formatting exactly', (t) => {
    resetMocks();

    const originalLines = [
        '2024-12-15 14:30:45.123 [+] agent: Hook installed',
        '2024-12-15 14:30:45.456 [*] agent: Processing request',
        '2024-12-15 14:30:45.789 [-] agent: Error occurred'
    ];

    const logger = new Logger('test-module');
    originalLines.forEach(line => logger.raw(line));

    t.is(consoleLogCalls.length, 3);
    originalLines.forEach((line, index) => {
        t.is(consoleLogCalls[index], line, `Line ${index} should be preserved exactly`);
    });

    restoreConsole();
});

test('Logger.raw() handles empty string', (t) => {
    resetMocks();

    const logger = new Logger('test-module');
    logger.raw('');

    t.is(consoleLogCalls.length, 1);
    t.is(consoleLogCalls[0], '');

    restoreConsole();
});

test('Logger.raw() handles whitespace-only strings', (t) => {
    resetMocks();

    const logger = new Logger('test-module');
    logger.raw('   ');
    logger.raw('\t\t');
    logger.raw('\n');

    t.is(consoleLogCalls.length, 3);
    t.is(consoleLogCalls[0], '   ');
    t.is(consoleLogCalls[1], '\t\t');
    t.is(consoleLogCalls[2], '\n');

    restoreConsole();
});

test('Logger.raw() handles special characters', (t) => {
    resetMocks();

    const specialChars = '2024-12-15 14:30:45.123 [+] test: Special chars: "quotes" <brackets> {braces} [arrays] & | $ @ # % ^ * ( )';
    const logger = new Logger('test-module');
    logger.raw(specialChars);

    t.is(consoleLogCalls.length, 1);
    t.is(consoleLogCalls[0], specialChars);

    restoreConsole();
});

test('Logger.raw() handles unicode and emoji', (t) => {
    resetMocks();

    const unicodeLine = '2024-12-15 14:30:45.123 [+] test: Unicode: æ—¥æœ¬èªž ä¸­æ–‡ í•œêµ­ì–´ ðŸŽ‰ âœ… ðŸš€';
    const logger = new Logger('test-module');
    logger.raw(unicodeLine);

    t.is(consoleLogCalls.length, 1);
    t.is(consoleLogCalls[0], unicodeLine);
    t.true(consoleLogCalls[0].includes('æ—¥æœ¬èªž'));
    t.true(consoleLogCalls[0].includes('ðŸŽ‰'));

    restoreConsole();
});

test('Logger.raw() handles very long lines', (t) => {
    resetMocks();

    const longMessage = 'A'.repeat(10000);
    const longLine = `2024-12-15 14:30:45.123 [+] test: ${longMessage}`;
    const logger = new Logger('test-module');
    logger.raw(longLine);

    t.is(consoleLogCalls.length, 1);
    t.is(consoleLogCalls[0], longLine);
    t.true(consoleLogCalls[0].length > 10000);

    restoreConsole();
});

test('Logger.raw() handles lines without timestamps', (t) => {
    resetMocks();

    const noTimestampLine = '[+] agent: Message without timestamp';
    const logger = new Logger('test-module');
    logger.raw(noTimestampLine);

    t.is(consoleLogCalls.length, 1);
    t.is(consoleLogCalls[0], noTimestampLine);

    restoreConsole();
});

test('Logger.raw() handles malformed timestamp formats', (t) => {
    resetMocks();

    const malformedLines = [
        '2024-12-15 [+] agent: Missing time',
        '14:30:45.123 [+] agent: Missing date',
        'INVALID [+] agent: No timestamp at all',
        '2024/12/15 14:30:45 [+] agent: Wrong separator'
    ];

    const logger = new Logger('test-module');
    malformedLines.forEach(line => logger.raw(line));

    t.is(consoleLogCalls.length, 4);
    malformedLines.forEach((line, index) => {
        t.is(consoleLogCalls[index], line);
    });

    restoreConsole();
});

test('Logger.raw() works concurrently with regular logging', (t) => {
    resetMocks();

    const logger = new Logger('test-module');

    // Mix regular and raw logging
    logger.info('Regular info message');
    logger.raw('2024-12-15 14:30:45.123 [+] frida: Raw message 1');
    logger.debug('Regular debug message');
    logger.raw('2024-12-15 14:30:45.456 [*] frida: Raw message 2');
    logger.error('Regular error message');
    logger.raw('2024-12-15 14:30:45.789 [-] frida: Raw message 3');

    t.is(consoleLogCalls.length, 6);

    // Regular messages should have timestamps added
    t.true(consoleLogCalls[0].includes('[+] test-module: Regular info message'));
    t.true(consoleLogCalls[2].includes('[*] test-module: Regular debug message'));
    t.true(consoleLogCalls[4].includes('[-] test-module: Regular error message'));

    // Raw messages should be unchanged
    t.is(consoleLogCalls[1], '2024-12-15 14:30:45.123 [+] frida: Raw message 1');
    t.is(consoleLogCalls[3], '2024-12-15 14:30:45.456 [*] frida: Raw message 2');
    t.is(consoleLogCalls[5], '2024-12-15 14:30:45.789 [-] frida: Raw message 3');

    restoreConsole();
});

test('Logger.raw() instance and static methods produce same output', (t) => {
    resetMocks();

    const testLine = '2024-12-15 14:30:45.123 [+] test: Same output test';
    const logger = new Logger('test-module');

    logger.raw(testLine);
    Logger.raw(testLine);

    t.is(consoleLogCalls.length, 2);
    t.is(consoleLogCalls[0], consoleLogCalls[1]);
    t.is(consoleLogCalls[0], testLine);

    restoreConsole();
});

test('Logger.raw() handles multiple consecutive calls', (t) => {
    resetMocks();

    const logger = new Logger('test-module');
    const lines = [
        '2024-12-15 14:30:45.100 [+] frida: Line 1',
        '2024-12-15 14:30:45.200 [+] frida: Line 2',
        '2024-12-15 14:30:45.300 [+] frida: Line 3',
        '2024-12-15 14:30:45.400 [+] frida: Line 4',
        '2024-12-15 14:30:45.500 [+] frida: Line 5'
    ];

    lines.forEach(line => logger.raw(line));

    t.is(consoleLogCalls.length, 5);
    lines.forEach((line, index) => {
        t.is(consoleLogCalls[index], line);
    });

    restoreConsole();
});

test('Logger.raw() handles rapid successive calls', (t) => {
    resetMocks();

    const logger = new Logger('test-module');
    const count = 100;

    for (let i = 0; i < count; i++) {
        logger.raw(`2024-12-15 14:30:45.${String(i).padStart(3, '0')} [+] frida: Message ${i}`);
    }

    t.is(consoleLogCalls.length, count);

    // Verify all messages are preserved in order
    for (let i = 0; i < count; i++) {
        t.true(consoleLogCalls[i].includes(`Message ${i}`));
    }

    restoreConsole();
});

test('Logger.raw() with multiple logger instances', (t) => {
    resetMocks();

    const logger1 = new Logger('module-1');
    const logger2 = new Logger('module-2');

    logger1.raw('2024-12-15 14:30:45.123 [+] frida: From logger1');
    logger2.raw('2024-12-15 14:30:45.456 [+] frida: From logger2');
    logger1.raw('2024-12-15 14:30:45.789 [+] frida: From logger1 again');

    t.is(consoleLogCalls.length, 3);
    t.is(consoleLogCalls[0], '2024-12-15 14:30:45.123 [+] frida: From logger1');
    t.is(consoleLogCalls[1], '2024-12-15 14:30:45.456 [+] frida: From logger2');
    t.is(consoleLogCalls[2], '2024-12-15 14:30:45.789 [+] frida: From logger1 again');

    restoreConsole();
});

test('Logger.raw() preserves line breaks and formatting', (t) => {
    resetMocks();

    const multilineContent = '2024-12-15 14:30:45.123 [+] frida: Line 1\nLine 2\nLine 3';
    const logger = new Logger('test-module');
    logger.raw(multilineContent);

    t.is(consoleLogCalls.length, 1);
    t.is(consoleLogCalls[0], multilineContent);
    t.true(consoleLogCalls[0].includes('\n'));

    restoreConsole();
});

test('Logger.raw() handles JSON-formatted output', (t) => {
    resetMocks();

    const jsonOutput = '2024-12-15 14:30:45.123 [+] frida: {"status":"success","data":{"key":"value"}}';
    const logger = new Logger('test-module');
    logger.raw(jsonOutput);

    t.is(consoleLogCalls.length, 1);
    t.is(consoleLogCalls[0], jsonOutput);
    t.true(consoleLogCalls[0].includes('{"status":"success"'));

    restoreConsole();
});

test('Logger.raw() integration with Frida output simulation', (t) => {
    resetMocks();

    const logger = new Logger('frida-manager');

    // Simulate typical Frida script output
    logger.raw('2024-12-15 14:30:45.123 [+] weather-widget-mod: Agent started');
    logger.raw('2024-12-15 14:30:45.234 [*] weather-widget-mod: Loading configuration');
    logger.raw('2024-12-15 14:30:45.345 [+] weather-widget-mod: API key: test-key-12345');
    logger.raw('2024-12-15 14:30:45.456 [*] weather-widget-mod: Installing OkHttp3 hooks');
    logger.raw('2024-12-15 14:30:45.567 [+] weather-widget-mod: Hooks installed successfully');
    logger.raw('2024-12-15 14:30:45.678 [*] weather-widget-mod: Intercepting request: http://api.example.com/weather');
    logger.raw('2024-12-15 14:30:45.789 [+] weather-widget-mod: Response modified');

    t.is(consoleLogCalls.length, 7);

    // Verify all lines preserved exactly
    t.true(consoleLogCalls[0].includes('Agent started'));
    t.true(consoleLogCalls[1].includes('Loading configuration'));
    t.true(consoleLogCalls[2].includes('API key: test-key-12345'));
    t.true(consoleLogCalls[3].includes('Installing OkHttp3 hooks'));
    t.true(consoleLogCalls[4].includes('Hooks installed successfully'));
    t.true(consoleLogCalls[5].includes('Intercepting request'));
    t.true(consoleLogCalls[6].includes('Response modified'));

    // Verify no double timestamps
    consoleLogCalls.forEach(log => {
        const timestampMatches = log.match(/\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{3}/g);
        t.is(timestampMatches.length, 1, 'Each line should have exactly one timestamp');
    });

    restoreConsole();
});

test('Logger.raw() performance with high volume', (t) => {
    resetMocks();

    const logger = new Logger('performance-test');
    const startTime = Date.now();
    const messageCount = 1000;

    for (let i = 0; i < messageCount; i++) {
        logger.raw(`2024-12-15 14:30:45.${String(i).padStart(3, '0')} [+] test: Message ${i}`);
    }

    const duration = Date.now() - startTime;

    t.is(consoleLogCalls.length, messageCount);
    t.true(duration < 1000, `Should process ${messageCount} messages in under 1 second (took ${duration}ms)`);

    restoreConsole();
});

test('Logger.raw() does not modify source property', (t) => {
    const logger = new Logger('test-module');
    const originalSource = logger.source;

    logger.raw('2024-12-15 14:30:45.123 [+] frida: Raw message');

    t.is(logger.source, originalSource);
    t.is(logger.source, 'test-module');
});

test('Logger.raw() static method works without instance', (t) => {
    resetMocks();

    // Use static method directly without creating instance
    Logger.raw('2024-12-15 14:30:45.123 [+] static: Message 1');
    Logger.raw('2024-12-15 14:30:45.456 [+] static: Message 2');

    t.is(consoleLogCalls.length, 2);
    t.is(consoleLogCalls[0], '2024-12-15 14:30:45.123 [+] static: Message 1');
    t.is(consoleLogCalls[1], '2024-12-15 14:30:45.456 [+] static: Message 2');

    restoreConsole();
});
